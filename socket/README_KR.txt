# IoT 센서 데이터 수집 시스템

RSA-2048 암호화, 다중 클라이언트 지원, 네트워크 기반 공개키 배포를 지원하는 안전한 IoT 센서 데이터 수집 시스템입니다.

## 개요

이 시스템은 두 가지 주요 구성요소로 이루어져 있습니다:
- **서버**: 여러 클라이언트로부터 암호화된 센서 데이터를 수신하고 처리
- **클라이언트**: IoT 센서를 시뮬레이션하여 서버로 암호화된 데이터 전송

## 핵심 기능

### 보안
- **RSA-2048 암호화**: 모든 센서 데이터를 RSA-2048과 PKCS1_OAEP 패딩으로 암호화
- **네트워크 공개키 배포**: 클라이언트가 서버에서 자동으로 공개키 획득
- **센서 인증**: 서버에서 등록된 센서 ID 검증
- **패킷 무결성**: 모든 데이터 패킷의 체크섬 검증

### 네트워크 및 배포
- **다중 클라이언트 지원**: 서버가 여러 클라이언트의 동시 연결 처리
- **크로스 플랫폼**: Windows, Linux, macOS에서 동작
- **독립 배포**: 완전히 독립적인 실행 파일
- **외부 의존성 없음**: 모든 모듈이 실행 파일에 내장
- **네트워크 설정**: JSON 파일을 통한 간편한 서버 IP 설정

### 데이터 처리
- **32바이트 센서 패킷**: 센서 측정값을 포함한 구조화된 데이터 형식
- **지오해시 위치 인코딩**: GPS 좌표의 효율적인 저장
- **MySQL 데이터베이스 연동**: 자동 센서 데이터 저장
- **실시간 처리**: 실시간 센서 데이터 모니터링 및 로깅

## 아키텍처

```
[클라이언트 1] ──┐
[클라이언트 2] ──┼─→ [서버] ──→ [MySQL 데이터베이스]
[클라이언트 N] ──┘
```

### 데이터 플로우
1. 서버가 시작 시 RSA 키 쌍 생성
2. 클라이언트가 서버에 공개키 요청 (네트워크 기반)
3. 클라이언트가 32바이트 센서 패킷 생성 (온도, 산소, 수온, GPS, 타임스탬프)
4. 클라이언트가 서버의 공개키로 패킷 암호화
5. 클라이언트가 TCP를 통해 암호화된 데이터 전송
6. 서버가 패킷 복호화 및 검증
7. 서버가 MySQL 데이터베이스에 데이터 저장

### 패킷 구조 (32바이트)
```
STX(1) + ID(2) + LEN(3) + TEMP(2) + O2(2) + WATER_TEMP(2) + 
GEOHASH(10) + TIMESTAMP(6) + CHECKSUM(2) + ETX(1)
```

## 설치 및 사용법

### 서버 패키지

**위치**: `server_package/`

**파일들**:
- `IoT_Sensor_Server.exe` - 독립 실행 서버 파일 (8.82 MB)
- `README.txt` - 상세한 서버 사용법
- `build_independent.py` - 개발용 빌드 스크립트

**서버 실행**:
1. `IoT_Sensor_Server.exe` 실행
2. 서버가 자동으로 RSA 키 생성 (private.pem, public.pem)
3. 포트 12351에서 클라이언트 연결 대기 시작
4. 클라이언트 연결 준비 완료

**요구사항**:
- MySQL 데이터베이스 설정 (데이터 저장용)
- 포트 12351 사용 가능 (사용 중이면 자동으로 해결)

### 클라이언트 패키지

**위치**: `client_package/`

**파일들**:
- `IoT_Sensor_Client.exe` - 독립 실행 클라이언트 파일 (8.31 MB)
- `config.json` - 클라이언트 설정 파일
- `README.txt` - 상세한 클라이언트 사용법
- `build_independent.py` - 개발용 빌드 스크립트

**클라이언트 설정** (`config.json`):
```json
{
    "server": {
        "address": "192.168.1.100",  // 서버 IP 주소
        "port": 12351               // 서버 포트
    },
    "client": {
        "sensor_id": "SENSOR_001",  // 고유 센서 식별자
        "send_interval": 10,        // 데이터 전송 간격 (초)
        "public_key_path": "public.pem"
    }
}
```

**클라이언트 실행**:
1. `config.json`에서 서버 IP 주소 설정
2. 각 클라이언트마다 고유한 `sensor_id` 설정
3. `IoT_Sensor_Client.exe` 실행
4. 클라이언트가 서버에서 자동으로 공개키 획득
5. N초마다 암호화된 센서 데이터 전송 시작

## 다중 클라이언트 배포

### 서버 배포
1. `server_package/IoT_Sensor_Server.exe`를 서버 기기에 복사
2. 실행 파일 실행
3. 다중 클라이언트 연결 준비 완료

### 클라이언트 배포
각 센서 위치별로:
1. `client_package/` 폴더를 클라이언트 기기에 복사
2. `config.json` 편집:
   - 서버 IP 주소 설정
   - 고유한 센서 ID 설정 (예: SENSOR_A01, SENSOR_B01 등)
   - 필요시 전송 간격 조정
3. `IoT_Sensor_Client.exe` 실행
4. 각 클라이언트가 독립적으로 동작

### 다중 클라이언트 설정 예시
```
서버 (192.168.1.100):
└── IoT_Sensor_Server.exe

클라이언트 A (센서 위치 A):
├── IoT_Sensor_Client.exe
└── config.json (sensor_id: "SENSOR_A01")

클라이언트 B (센서 위치 B):
├── IoT_Sensor_Client.exe
└── config.json (sensor_id: "SENSOR_B01")

클라이언트 C (센서 위치 C):
├── IoT_Sensor_Client.exe
└── config.json (sensor_id: "SENSOR_C01")
```

## 데이터베이스 설정

시스템은 다음 스키마를 가진 MySQL 데이터베이스가 필요합니다:

### 데이터베이스: `livecon_db`

**테이블: `sensor_info`**
- 등록된 센서 ID 저장
- 센서 인증에 사용

**테이블: `sensor_result`**
- 모든 센서 측정값 저장
- 위치 데이터와 타임스탬프 포함

### 연결 설정
데이터베이스 연결 설정은 서버에서 내부적으로 처리됩니다. MySQL이 실행 중이고 접근 가능한지 확인하세요.

## 네트워크 요구사항

### 방화벽 설정
- **서버**: 포트 12351에서 들어오는 연결 허용
- **클라이언트**: 서버 IP의 포트 12351로 나가는 연결 허용

### 네트워크 토폴로지
- 클라이언트와 서버는 동일 LAN 또는 인터넷을 통해 연결 가능
- 각 클라이언트는 서버와 TCP 연결 필요
- 기본 LAN 설정에서는 특별한 라우팅이나 포트 포워딩 불필요

## 개발 및 빌드

### 전제조건
- Python 3.7+
- PyInstaller
- 필요 패키지: pycryptodome, pymysql

### 빌드 과정
```bash
# 서버
cd server_package
python build_independent.py

# 클라이언트  
cd client_package
python build_independent.py
```

### 소스 코드 구조
```
server_package/
├── server.py              # 메인 서버 애플리케이션
├── server_module/         # 서버 유틸리티 모듈
│   ├── rsa_utils.py      # RSA 암호화/복호화
│   ├── parsing.py        # 패킷 파싱 및 검증
│   ├── sql_utils.py      # 데이터베이스 연산
│   ├── checksum.py       # 패킷 무결성 검증
│   └── geohash_decode.py # 위치 데이터 디코딩

client_package/
├── client.py              # 메인 클라이언트 애플리케이션
├── node_module/          # 클라이언트 유틸리티 모듈
│   ├── rsa_utils.py      # RSA 암호화
│   ├── generate_packet.py # 센서 데이터 패킷 생성
│   └── geohash_encode.py # 위치 데이터 인코딩
```

## 문제 해결

### 서버 문제
- **포트 이미 사용 중**: 서버가 자동으로 포트 충돌 해결
- **데이터베이스 연결 실패**: MySQL 서비스와 자격증명 확인
- **키 생성 실패**: 서버 디렉토리의 쓰기 권한 확인

### 클라이언트 문제
- **연결 거부됨**: 서버 실행 상태와 IP 주소 정확성 확인
- **공개키 획득 실패**: 서버와의 네트워크 연결 확인
- **센서 ID 검증 실패**: 데이터베이스에 센서 ID 등록 여부 확인

### 네트워크 문제
- **방화벽 차단**: 방화벽 설정에서 포트 12351 허용
- **IP 주소 접근 불가**: 네트워크 연결 확인
- **타임아웃 오류**: 네트워크 지연시간 또는 패킷 손실 확인

## 보안 고려사항

### 암호화
- RSA-2048가 센서 데이터에 강력한 보안 제공
- 각 패킷이 개별적으로 암호화됨
- 보안 채널을 통한 공개키 배포

### 인증
- 서버가 데이터베이스와 비교하여 모든 센서 ID 검증
- 미등록 센서 자동 차단
- 감사 목적의 연결 로깅

### 모범 사례
- 서버 개인키 보안 유지 (private.pem)
- 필요시 정기적인 암호화 키 교체
- 비정상적인 활동에 대한 연결 로그 모니터링
- 가능한 경우 보안 네트워크 연결 사용

## 성능

### 서버 용량
- 100개 이상의 동시 클라이언트 연결 지원
- 멀티스레드 클라이언트 처리
- 효율적인 패킷 처리 및 데이터베이스 연산

### 네트워크 사용량
- 센서 패킷당: 32바이트 (원본) → 256바이트 (암호화)
- 기본 전송 간격: 클라이언트당 10초
- 대역폭 사용량: 클라이언트당 약 25바이트/초

### 시스템 요구사항
- **서버**: 2GB RAM, 1GB 디스크 공간, 네트워크 연결
- **클라이언트**: 512MB RAM, 100MB 디스크 공간, 네트워크 연결

## 라이선스 및 지원

이것은 엔터프라이즈급 보안 기능을 갖춘 IoT 센서 데이터 수집 시스템 데모입니다.

기술 지원이나 배포 지원이 필요한 경우, 각 패키지 폴더의 개별 README.txt 파일을 참조하세요.

## 버전 정보

- **서버 패키지**: v1.0 - 독립 실행형 암호화 센서 데이터 서버
- **클라이언트 패키지**: v1.0 - 독립 실행형 센서 시뮬레이터 클라이언트
- **암호화**: RSA-2048 with PKCS1_OAEP 패딩
- **네트워크 프로토콜**: 자동 공개키 배포 기능을 가진 TCP
- **데이터베이스**: 센서 인증 기능을 가진 MySQL 연동

## 주요 특징 요약

### 🔒 보안
- RSA-2048 엔드투엔드 암호화
- 자동 공개키 배포
- 센서 ID 기반 인증

### 🌐 네트워크
- 멀티 클라이언트 동시 연결
- 자동 포트 충돌 해결
- 크로스 플랫폼 지원

### 📦 배포
- 완전 독립 실행 파일
- 외부 의존성 없음
- 간편한 JSON 설정

### 💾 데이터
- 구조화된 32바이트 패킷
- MySQL 실시간 저장
- 지오해시 위치 인코딩

### 🔧 운영
- 자동 서버 정리
- 실시간 모니터링
- 포괄적인 로깅

이 시스템은 상용 IoT 센서 네트워크 구축에 필요한 모든 기능을 제공합니다.